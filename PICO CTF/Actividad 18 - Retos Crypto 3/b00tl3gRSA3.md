Why use p and q when I can use more? Connect with `nc jupiter.challenges.picoctf.org 3726`.
Hints:
- There's more prime factors than p and q, finding d is going to be different.
# Solución
Por este problema, se nos ha dado c, n y e. Normalmente, esto sería difícil de romper. Sin embargo, nos hemos dicho que hay más factores que p y q que se utilizan para encontrar n.
Como tal, esto debe ser fácilmente factorizable, ya que ser difícil de tener en cuenta depende de que sean sólo dos grandes primos. Una manera fácil de hacer esto rápidamente es con [alpertron](https://www.alpertron.com.ar/ECM.HTM) y usando el siguiente script de python
```
c = 26157389423844561894545811905872485492696864414047657221375804564466402864650814261394016582234416630998693905262311759506175442829487697818781285453660862860817861353440043145639526057914579306942421613725925669939147527137114474980171573320103768249152732704997973518946697944950589008888623403354463334909835911057593004119334405051110525367
n = 33242229907626537431120627620575901194897904075440913474793978243995175684219320560583579516922212639370313068596411979952803242314856166835551658751059386148397432865269343078586467061999316117565770447706502748264353904482208702006585360833126683835423746604935833248187677678629167111668976076731978397872615578552264937931453633099111480921
e = 65537

phi = euler_phi(n)

d = inverse_mod(e, phi)

m = pow(c, d, n)

m = hex(m)[2:]

m = bytearray.fromhex(m).decode()

print(m)
```
picoCTF{too_many_fact0rs_8606199}